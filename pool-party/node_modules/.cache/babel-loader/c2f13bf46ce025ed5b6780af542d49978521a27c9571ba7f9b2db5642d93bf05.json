{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\nclass Context {\n  constructor(fields, locations, stack, optional, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n  get errors() {\n    return this._errors;\n  }\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      requiredOnly: false\n    };\n    // Have to store this.optional in a const otherwise TS thinks the value could have changed\n    // when the functions below run\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional.nullable ? value != null : true, value => optional.checkFalsy ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location');\n      // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n    });\n  }\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n    instance.value = value;\n  }\n  addError(message, valueOrNestedErrors, meta) {\n    const msg = message || this.message || 'Invalid value';\n    if (meta) {\n      this._errors.push({\n        value: valueOrNestedErrors,\n        msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n        param: meta.path,\n        location: meta.location\n      });\n    } else {\n      this._errors.push({\n        msg,\n        param: '_error',\n        nestedErrors: valueOrNestedErrors\n      });\n    }\n  }\n}\nexports.Context = Context;","map":{"version":3,"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","constructor","fields","locations","stack","optional","message","_errors","dataMap","Map","errors","getData","options","requiredOnly","checks","undefined","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","length","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","assign","setData","get","Error","addError","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"sources":["/Users/collin/SeniorProject/pool-party/node_modules/express-validator/src/context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    constructor(fields, locations, stack, optional, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    get errors() {\n        return this._errors;\n    }\n    getData(options = { requiredOnly: false }) {\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\n        // when the functions below run\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional.nullable ? value != null : true),\n                (value) => (optional.checkFalsy ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(message, valueOrNestedErrors, meta) {\n        const msg = message || this.message || 'Invalid value';\n        if (meta) {\n            this._errors.push({\n                value: valueOrNestedErrors,\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n                param: meta.path,\n                location: meta.location,\n            });\n        }\n        else {\n            this._errors.push({\n                msg,\n                param: '_error',\n                nestedErrors: valueOrNestedErrors,\n            });\n        }\n    }\n}\nexports.Context = Context;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}